#include <SSD1306Wire.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ArduinoJson.h>

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏—Å–ø–ª–µ—è (SDA - D1/IO5, SCL - D2/IO4)
SSD1306Wire display(0x3c, 5, 4);

// Wi-Fi –∏ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä
const char* ssid = "ESP8266_Moshi";
const char* password = "12345678";
ESP8266WebServer server(80);


struct Emotion {
  const unsigned char* frames[4]; 
  int frameCount;
  const char* text;
  const char* emoji;
};

Emotion emotions[] = {
  {{happy_face, happy_face_blink, happy_face_open, happy_face}, 4, "Happy!", "üòä"},
  {{sad_face_blink, sad_face_blink, sad_face_frown, sad_face_blink}, 4, "Sad...", "üò¢"},
  {{surprised_face, surprised_face_blink, surprised_face_open, surprised_face}, 4, "Wow!", "üòÆ"},
  {{sleepy_face, sleepy_face_blink, sleepy_face_yawn, sleepy_face}, 4, "Sleepy...", "üò¥"},
  {{love_face, love_face_blink, love_face_hearts, love_face}, 4, "In Love!", "üòç"},
  {{angry_face, angry_face_blink, angry_face_scowl, angry_face}, 4, "Angry!", "üò£"},
  {{confused_face, confused_face_blink, confused_face_tilt, confused_face}, 4, "Confused?", "üòï"}
};
const int num_emotions = 7;

int lastClientCount = 0;
unsigned long lastConnectionTime = 0;
unsigned long lastIdleChange = 0;
unsigned long lastFrameChange = 0;
unsigned long lastEnergyChange = 0;
unsigned long lastHungerChange = 0;
unsigned long lastBoredomChange = 0;
int currentEmotion = -1;
int previousEmotion = -1;
int currentFrame = 0;
int energy = 100;
int hunger = 100;
int boredom = 100;
String customMessage = "";
const unsigned long idleInterval = 10000;
const unsigned long frameInterval = 200; 
const unsigned long energyInterval = 60000;
const unsigned long hungerInterval = 45000;
const unsigned long boredomInterval = 30000;
bool inTransition = false;
unsigned long transitionStartTime = 0;
const unsigned long transitionDuration = 2000; 
const unsigned long guessGameDuration = 30000; 
int energyHistory[10] = {100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
int energyHistoryIndex = 0;

int emotionFrequency[num_emotions] = {0};

struct Transition {
  int fromEmotion;
  int toEmotion;
  int transitionEmotion;
};

Transition transitions[] = {
  {0, 1, 6}, // Happy -> Sad —á–µ—Ä–µ–∑ Confused
  {1, 0, 6}, // Sad -> Happy —á–µ—Ä–µ–∑ Confused
  {0, 2, 6}, // Happy -> Surprised —á–µ—Ä–µ–∑ Confused
  {2, 0, 6}, // Surprised -> Happy —á–µ—Ä–µ–∑ Confused
  {1, 3, 6}, // Sad -> Sleepy —á–µ—Ä–µ–∑ Confused
  {3, 1, 6}  // Sleepy -> Sad —á–µ—Ä–µ–∑ Confused
};
const int num_transitions = 6;
bool adventureMode = false;
unsigned long adventureStartTime = 0;
int adventureSequence[] = {0, 2, 4, 6, 1, 3}; // Happy, Surprised, Love, Confused, Sad, Sleepy
int adventureIndex = 0;
const unsigned long adventureInterval = 15000;

bool guessGameActive = false;
int guessGameEmotion = -1;
unsigned long guessGameStartTime = 0;

void displayEmotion(int emotion, int frame) {
  display.clear();
  display.drawXbm(48, 0, 32, 32, emotions[emotion].frames[frame]);
  display.setFont(ArialMT_Plain_10);
  display.setTextAlignment(TEXT_ALIGN_CENTER);
  if (guessGameActive) {
    display.drawString(64, 40, "Guess my emotion!");
  } else {
    display.drawString(64, 40, emotions[emotion].text);
  }
  display.display();
}

void updateEmotionBasedOnState() {
  if (guessGameActive || adventureMode || inTransition) return;

  int maxFrequency = 0;
  for (int i = 0; i < num_emotions; i++) {
    if (emotionFrequency[i] > maxFrequency) maxFrequency = emotionFrequency[i];
  }

  if (energy <= 30 || hunger <= 30) {
    setEmotion(3); // Sleepy
  } else if (hunger <= 50) {
    setEmotion(1); // Sad
  } else if (boredom <= 50) {
    setEmotion(6); // Confused
  } else if (maxFrequency > 5 && emotionFrequency[4] == maxFrequency) {
    setEmotion(4); // Love
  } else {
    setEmotion(0); // Happy
  }
}
void setEmotion(int newEmotion) {
  if (newEmotion == currentEmotion || guessGameActive || adventureMode) return;

  emotionFrequency[newEmotion]++;
  if (currentEmotion != -1) {
    for (int i = 0; i < num_transitions; i++) {
      if (transitions[i].fromEmotion == currentEmotion && transitions[i].toEmotion == newEmotion) {
        inTransition = true;
        transitionStartTime = millis();
        previousEmotion = currentEmotion;
        currentEmotion = transitions[i].transitionEmotion;
        currentFrame = 0;
        displayEmotion(currentEmotion, currentFrame);
        return;
      }
    }
  }
  previousEmotion = currentEmotion;
  currentEmotion = newEmotion;
  currentFrame = 0;
  displayEmotion(currentEmotion, currentFrame);
}

void handleStatus() {
  StaticJsonDocument<512> doc;
  doc["emotion"] = (currentEmotion >= 0) ? emotions[currentEmotion].text : "None";
  doc["energy"] = energy;
  doc["hunger"] = hunger;
  doc["boredom"] = boredom;
  doc["lastActive"] = lastConnectionTime / 1000;
  doc["message"] = customMessage;
  JsonArray history = doc.createNestedArray("energyHistory");
  for (int i = 0; i < 10; i++) {
    history.add(energyHistory[i]);
  }
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleSetEnergy() {
  if (server.hasArg("plain")) {
    StaticJsonDocument<200> doc;
    deserializeJson(doc, server.arg("plain"));
    energy = doc["energy"].as<int>();
    if (energy > 100) energy = 100;
    if (energy < 0) energy = 0;
    energyHistory[energyHistoryIndex] = energy;
    energyHistoryIndex = (energyHistoryIndex + 1) % 10;
    updateEmotionBasedOnState();
    server.send(200, "application/json", "{\"status\":\"ok\"}");
  } else {
    server.send(400, "application/json", "{\"error\":\"Invalid request\"}");
  }
}

void handleSetMessage() {
  if (server.hasArg("plain")) {
    StaticJsonDocument<200> doc;
    deserializeJson(doc, server.arg("plain"));
    customMessage = doc["message"].as<String>();
    server.send(200, "application/json", "{\"status\":\"ok\"}");
  } else {
    server.send(400, "application/json", "{\"error\":\"Invalid request\"}");
  }
}

void handleHappy() { setEmotion(0); server.send(200, "application/json", "{\"status\":\"ok\"}"); }
void handleSad() { setEmotion(1); server.send(200, "application/json", "{\"status\":\"ok\"}"); }
void handleSurprised() { setEmotion(2); server.send(200, "application/json", "{\"status\":\"ok\"}"); }
void handleSleepy() { setEmotion(3); server.send(200, "application/json", "{\"status\":\"ok\"}"); }
void handleLove() { setEmotion(4); server.send(200, "application/json", "{\"status\":\"ok\"}"); }
void handleAngry() { setEmotion(5); server.send(200, "application/json", "{\"status\":\"ok\"}"); }
void handleConfused() { setEmotion(6); server.send(200, "application/json", "{\"status\":\"ok\"}"); }

void handleFeed() {
  hunger = min(hunger + 15, 100);
  updateEmotionBasedOnState();
  server.send(200, "application/json", "{\"status\":\"ok\"}");
}

void handlePlay() {
  boredom = min(boredom + 15, 100);
  updateEmotionBasedOnState();
  server.send(200, "application/json", "{\"status\":\"ok\"}");
}

void handleAdventure() {
  if (!adventureMode) {
    adventureMode = true;
    adventureIndex = 0;
    adventureStartTime = millis();
    setEmotion(adventureSequence[adventureIndex]);
  }
  server.send(200, "application/json", "{\"status\":\"ok\"}");
}

void handleGuessGame() {
  if (!guessGameActive) {
    guessGameActive = true;
    guessGameEmotion = random(num_emotions);
    guessGameStartTime = millis();
    setEmotion(guessGameEmotion);
  }
  server.send(200, "application/json", "{\"status\":\"ok\"}");
}

void handleGuessEmotion() {
  if (server.hasArg("emotion")) {
    int guessedEmotion = server.arg("emotion").toInt();
    if (guessGameActive && guessedEmotion == guessGameEmotion) {
      customMessage = "Correct! Well done!";
      boredom = min(boredom + 20, 100);
    } else {
      customMessage = "Wrong! Try again!";
    }
    guessGameActive = false;
    updateEmotionBasedOnState();
    server.send(200, "application/json", "{\"status\":\"ok\"}");
  } else {
    server.send(400, "application/json", "{\"error\":\"Invalid request\"}");
  }
}

void setup() {
  Serial.begin(115200);

  display.init();
  display.flipScreenVertically();
  display.clear();
  display.setFont(ArialMT_Plain_10);
  display.drawString(0, 0, "Waiting for device...");
  display.display();

  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, password);
  Serial.println("–¢–æ—á–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —Å–æ–∑–¥–∞–Ω–∞: ");
  Serial.print("SSID: "); Serial.println(ssid);
  Serial.print("IP: "); Serial.println(WiFi.softAPIP());

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
  server.on("/", []() {
    String html = R"rawliteral(
      <!DOCTYPE html>
      <html>
      <head>
        <title>Moshi Control</title>
        <style>
          body { font-family: Arial; text-align: center; background: #f0f0f0; }
          .container { max-width: 600px; margin: auto; padding: 20px; }
          .status { margin: 20px 0; }
          .button { display: block; margin: 10px; padding: 10px; background: #4CAF50; color: white; text-decoration: none; border-radius: 5px; }
          .button:hover { background: #45a049; }
          canvas { margin: 20px auto; border: 1px solid #ccc; }
          input[type=range], input[type=text] { margin: 10px; padding: 5px; }
        </style>
        <script>
          function updateStatus() {
            fetch('/status').then(response => response.json()).then(data => {
              document.getElementById('emotion').innerText = data.emotion;
              document.getElementById('energy').innerText = data.energy;
              document.getElementById('hunger').innerText = data.hunger;
              document.getElementById('boredom').innerText = data.boredom;
              document.getElementById('lastActive').innerText = new Date(data.lastActive * 1000).toLocaleTimeString();
              document.getElementById('message').innerText = data.message || 'No message';
              let ctx = document.getElementById('energyChart').getContext('2d');
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              ctx.beginPath();
              ctx.moveTo(0, 100 - data.energyHistory[0]);
              for (let i = 1; i < data.energyHistory.length; i++) {
                ctx.lineTo(i * 50, 100 - data.energyHistory[i]);
              }
              ctx.strokeStyle = 'blue';
              ctx.strokeemar);
            });
          }
          setInterval(updateStatus, 2000);
          function setEnergy() {
            let energy = document.getElementById('energySlider').value;
            fetch('/setEnergy', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ energy: energy })
            });
          }
          function sendMessage() {
            let message = document.getElementById('customMessage').value;
            fetch('/setMessage', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: message })
            });
          }
          function guessEmotion(emotion) {
            fetch('/guessEmotion?emotion=' + emotion).then(response => response.json()).then(data => {
              updateStatus();
            });
          }
        </script>
      </head>
      <body onload="updateStatus()">
        <div class="container">
          <h1>Moshi Control</h1>
          <div class="status">
            <p>Current Emotion: <span id="emotion">Waiting...</span></p>
            <p>Energy: <span id="energy">100</span></p>
            <p>Hunger: <span id="hunger">100</span></p>
            <p>Boredom: <span id="boredom">100</span></p>
            <p>Last Activity: <span id="lastActive">-</span></p>
            <p>Message: <span id="message">No message</span></p>
            <canvas id="energyChart" width="500" height="100"></canvas>
          </div>
          <a class="button" href="/happy">Make Happy</a>
          <a class="button" href="/sad">Make Sad</a>
          <a class="button" href="/surprised">Make Surprised</a>
          <a class="button" href="/sleepy">Make Sleepy</a>
          <a class="button" href="/love">Make In Love</a>
          <a class="button" href="/angry">Make Angry</a>
          <a class="button" href="/confused">Make Confused</a>
          <a class="button" href="/feed">Feed (+15 Hunger)</a>
          <a class="button" href="/play">Play (+15 Boredom)</a>
          <a class="button" href="/adventure">Start Adventure</a>
          <a class="button" href="/guessGame">Play Guess Emotion</a>
          <div>
            <input type="range" id="energySlider" min="0" max="100" value="100" oninput="setEnergy()">
            <input type="text" id="customMessage" placeholder="Enter message">
            <button class="button" onclick="sendMessage()">Send Message</button>
          </div>
          <div>
            <button class="button" onclick="guessEmotion(0)">Happy</button>
            <button class="button" onclick="guessEmotion(1)">Sad</button>
            <button class="button" onclick="guessEmotion(2)">Surprised</button>
            <button class="button" onclick="guessEmotion(3)">Sleepy</button>
            <button class="button" onclick="guessEmotion(4)">Love</button>
            <button class="button" onclick="guessEmotion(5)">Angry</button>
            <button class="button" onclick="guessEmotion(6)">Confused</button>
          </div>
        </div>
      </body>
      </html>
    )rawliteral";
    server.send(200, "text/html", html);
  });

  server.on("/status", handleStatus);
  server.on("/setEnergy", HTTP_POST, handleSetEnergy);
  server.on("/setMessage", HTTP_POST, handleSetMessage);
  server.on("/happy", handleHappy);
  server.on("/sad", handleSad);
  server.on("/surprised", handleSurprised);
  server.on("/sleepy", handleSleepy);
  server.on("/love", handleLove);
  server.on("/angry", handleAngry);
  server.on("/confused", handleConfused);
  server.on("/feed", handleFeed);
  server.on("/play", handlePlay);
  server.on("/adventure", handleAdventure);
  server.on("/guessGame", handleGuessGame);
  server.on("/guessEmotion", handleGuessEmotion);

  server.begin();
  Serial.println("–í–µ–±-—Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω");
}

void loop() {
  server.handleClient();

  unsigned long currentTime = millis();

  int currentClientCount = WiFi.softAPgetStationNum();
  if (currentClientCount > 0) {
    lastConnectionTime = currentTime;
  }
  if (currentClientCount != lastClientCount) {
    lastClientCount = currentClientCount;
    lastIdleChange = currentTime;
    updateEmotionBasedOnState();
  }
  if (currentTime - lastIdleChange > idleInterval && lastClientCount == 0 && currentEmotion != 3) {
    setEmotion(3); 
  }

  if (currentEmotion >= 0 && currentTime - lastFrameChange > frameInterval) {
    currentFrame = (currentFrame + 1) % emotions[currentEmotion].frameCount;
    displayEmotion(currentEmotion, currentFrame);
    lastFrameChange = currentTime;
  }

  if (currentTime - lastEnergyChange > energyInterval) {
    energy = max(energy - 5, 0);
    energyHistory[energyHistoryIndex] = energy;
    energyHistoryIndex = (energyHistoryIndex + 1) % 10;
    lastEnergyChange = currentTime;
    updateEmotionBasedOnState();
  }

  if (currentTime - lastHungerChange > hungerInterval) {
    hunger = max(hunger - 5, 0);
    lastHungerChange = currentTime;
    updateEmotionBasedOnState();
  }

  if (currentTime - lastBoredomChange > boredomInterval) {
    boredom = max(boredom - 5, 0);
    lastBoredomChange = currentTime;
    updateEmotionBasedOnState();
  }

  if (inTransition && currentTime - transitionStartTime > transitionDuration) {
    inTransition = false;
    int targetEmotion = -1;
    for (int i = 0; i < num_transitions; i++) {
      if (transitions[i].fromEmotion == previousEmotion && transitions[i].transitionEmotion == currentEmotion) {
        targetEmotion = transitions[i].toEmotion;
        break;
      }
    }
    if (targetEmotion != -1) {
      currentEmotion = targetEmotion;
      currentFrame = 0;
      displayEmotion(currentEmotion, currentFrame);
    }
  }

  if (adventureMode && currentTime - adventureStartTime > adventureInterval) {
    adventureIndex = (adventureIndex + 1) % 6;
    setEmotion(adventureSequence[adventureIndex]);
    adventureStartTime = currentTime;
    if (adventureIndex == 0) {
      adventureMode = false;
    }
  }

  if (guessGameActive && currentTime - guessGameStartTime > guessGameDuration) {
    guessGameActive = false;
    customMessage = "Time's up!";
    updateEmotionBasedOnState();
  }
}
